'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 7 November 2022 at 3:40:01.476051 pm'!Object subclass: #CPile	instanceVariableNames: 'contenu index capacite'	classVariableNames: 'tailleDefaut'	package: 'TD-HAI931-PileBase'!!CPile commentStamp: 'cd 4/2/2021 09:57' prior: 0!Implantation d'une pile en utilisant une collection ordonnée.!!CPile methodsFor: 'printing' stamp: 'cd 4/11/2021 12:38'!printOn2: aStream	"Cette méthode est appelée par la méthode printString qui fabrique une représentation du    receveur sous forme de chaîne.	 PrintString est elle-même appelée par les outils de l'environnement, par exemple par la    méthode printIt du Playground."	aStream nextPutAll: 'une '; nextPutAll: self class name; nextPutAll: ': ('.	contenu		do: [ :each | 			each printOn: aStream.			aStream space ].	aStream nextPut: $)! !!CPile methodsFor: 'printing' stamp: 'cd 4/2/2021 10:20'!printOn: aStream	"Cette méthode est appelée par la méthode printString qui fabrique une représentation du    receveur sous forme de chaîne.	 PrintString est elle-même appelée par les outils de l'environnement, par exemple par la    méthode printIt du Playground."	aStream nextPutAll: 'une ', self class name , ': ('.	contenu		do: [ :each | 			each printOn: aStream.			aStream space ].	aStream nextPut: $)! !!CPile methodsFor: 'tests' stamp: 'cd 4/7/2020 13:31'!test	self intercept: 33.! !!CPile methodsFor: 'enumerating' stamp: 'cd 9/28/2018 10:21'!do: aBlock	"un itérateur pour la classe Pile"	contenu do: aBlock! !!CPile methodsFor: 'métier' stamp: 'cd 4/10/2021 17:40'!pop	"dépile et rend le sommet de pile si la pile n'est pas vide"	| retour |	self isEmpty		ifFalse: [			retour := contenu at: index.			index := index - 1.			^retour]		ifTrue: [ self error: 'Pile vide, Impossible de dépiler' ]! !!CPile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:06'!size	"donne le nombre d'éléments empilés"	^index		"^contenu count: [ :each | each isNotNil ]"	! !!CPile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:55'!top	"rend le sommet de pile si la pile n'est pas vide, sans dépiler"	self isEmpty		ifFalse: [ ^contenu at: index]		ifTrue: [ self error: 'Rien au sommet d''une pile vide' ]! !!CPile methodsFor: 'métier' stamp: 'cd 4/13/2021 16:01'!isEmpty	^index = 0.! !!CPile methodsFor: 'métier' stamp: 'cd 3/8/2017 12:25'!push: anObject	"met anObject dans contenu au bon index si la pile n'est pas pleine"	self isFull		ifFalse: [			index := index + 1.			contenu at: index put: anObject.]		ifTrue: [ self error: 'Impossible d''empiler sur une pile pleine' ]! !!CPile methodsFor: 'métier' stamp: 'cd 10/11/2021 13:48'!test23	^super = self! !!CPile methodsFor: 'métier' stamp: 'cd 3/28/2018 13:01'!capacity	^capacite	! !!CPile methodsFor: 'métier' stamp: 'cd 3/28/2018 12:53'!isFull	^index = capacite! !!CPile methodsFor: 'métier' stamp: 'cd 4/2/2021 10:15'!push2: element	self isFull		ifFalse: [index := index + 1.				contenu at:index put: element.]		ifTrue: [self error: 'Pile pleine'].! !!CPile methodsFor: 'initialization' stamp: 'cd 3/15/2019 11:14'!initialize	self initialize: tailleDefaut	! !!CPile methodsFor: 'initialization' stamp: 'cd 9/19/2022 15:40'!initialize: taille	"initialise les attributs du receveur"	"une pile est vide quand index = 0"	index := 0.	"la pile est pleine quand index = capacite"	capacite := taille.	"le contenu d'une pile est représenté par un tableau"	contenu := Array new: capacite.	! !!CPile methodsFor: 'private' stamp: 'cd 10/11/2021 11:34'!sauveGrow	"une méthode permettant de faire grossir une pile"	"déplacée dans l'exercice RefactorPile"	| nb oldc |	nb := self size.	oldc := contenu.	capacite := capacite * 2.	contenu := Array new: capacite.	index := 0.	1 to: nb do: [ :i | self push: (oldc at: i) ]! !!CPile methodsFor: 'private' stamp: 'cd 3/22/2019 18:28'!contenuEqual: contenuDeLaPileQueLonCompareAvecLeReceveur	^contenu = contenuDeLaPileQueLonCompareAvecLeReceveur! !!CPile methodsFor: 'comparing' stamp: 'cd 3/22/2019 18:28'!= uneAutrePile	"une solution pour écrire = sans  mettre un accesseur en lecture sur le buffer"	^uneAutrePile contenuEqual: contenu! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CPile class	instanceVariableNames: ''!!CPile class methodsFor: 'examples' stamp: 'cd 11/7/2022 11:34'!example	"self example" 	"Un exemple de la façon dont on peut utiliser une pile dans un programme"	| p |	p := CPile new.	p push: 33.	p push: 'une chaine'.	p push: 2 @ 3.	p push: 5 factorial.	p push: p isFull.	p pop.	p push: p size.	^p! !!CPile class methodsFor: 'instance creation' stamp: 'cd 11/7/2022 11:18'!initialize	"cette méthode n'est invoquée qu'une seule fois"	"initialisation de la variable de classe representant une propriete partagee par toutes les instances"	tailleDefaut := 5.	! !!CPile class methodsFor: 'instance creation' stamp: 'cd 4/16/2021 09:02'!newErwan: n|p|p := self new.p initialize n.^p.			! !!CPile class methodsFor: 'instance creation' stamp: 'cd 11/7/2022 15:39'!new: n	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"^super new initialize: n ! !!CPile class methodsFor: 'instance creation' stamp: 'cd 4/16/2021 09:03'!newFlorian: taille	^(super new) initialize: taille.	! !!CPile class methodsFor: 'instance creation' stamp: 'cd 11/7/2022 11:43'!new	"Ceci est une méthode de class.	Que vaut 'self'? La classe à laquelle a été envoyé le message ...	donc la class Pile ou une de ses sous-classes"^super new initialize: tailleDefaut ! !CPile initialize!